The Student Data Management System is a MySQL-based application that replaces manual attendance registers with a digital, efficient solution. It uses a normalized relational database with foreign keys to maintain data integrity and enable quick, optimized querying. The system includes features like student and subject management, attendance marking, percentage calculation, role-based logins, and attendance reports. Built with a full-stack architecture using Go fiber framework for the backend and React.js for the frontend, tailwind css and daisyUI for the stylings ,and lucide react for icons , it provides secure, real-time access to records. This project ensures scalable, accurate attendance tracking and serves as a foundation for future modules like reporting and notifications. 

Marking and Uploading Attendance:

Steps for the User 
1. Enter date
2. Select Hour
3. Select Subject
4. Mark Attendance of each student

Steps for the frontend

1. Store the date , hour and subject in the JSON 
2. Then store the student id and Existence status(Present/Absent) in an array

Steps for the backend 

1. Take the date , hour and subject from the request and store it in respective fields
2. Increment through the array in the JSON in the request. 
  2.1 In each increment insert into  attendance Table and then insert attendance_id and other details to the attendance_detail Table.
3. Then return Succes message 



-- Student Data Management System Database Schema
-- SOURCE /path/to/student_management.sql;

CREATE DATABASE IF NOT EXISTS student_management;
USE student_management;

-- Branch Table
CREATE TABLE branch (
    branch_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    department_head VARCHAR(100)
);

-- Subject Table
CREATE TABLE subject (
    subject_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(20) UNIQUE NOT NULL,
    branch_id INT,
    FOREIGN KEY (branch_id) REFERENCES branch(branch_id)
);

-- Semester Table
CREATE TABLE semester (
    semester_id INT PRIMARY KEY AUTO_INCREMENT,
    sem_num INT,
    branch_id INT,
    subject_id INT,
    FOREIGN KEY (branch_id) REFERENCES branch(branch_id),
    FOREIGN KEY (subject_id) REFERENCES subject(subject_id)
);

-- Class Table
CREATE TABLE batch (
    batch_id INT PRIMARY KEY AUTO_INCREMENT,
    branch_id INT,
    name VARCHAR(100) NOT NULL,
    started YEAR,
    semester_id INT,
    FOREIGN KEY (branch_id) REFERENCES branch(branch_id),
    FOREIGN KEY (semester_id) REFERENCES semester(semester_id)
);

-- Student Table
CREATE TABLE student (
    student_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    branch_id INT,
    batch_id INT,
    roll_number VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE,
    ph_no VARCHAR(20),
    password VARCHAR(255) NOT NULL,
    FOREIGN KEY (branch_id) REFERENCES branch(branch_id),
    FOREIGN KEY (batch_id) REFERENCES batch(batch_id)
);

-- Teacher Table
CREATE TABLE teacher (
    teacher_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    ph_no VARCHAR(20),
    password VARCHAR(255) NOT NULL
);


CREATE TABLE subject_cluster (
    teacher_id INT,
    subject_id INT,
    PRIMARY KEY (teacher_id,subject_id),
    FOREIGN KEY (teacher_id) REFERENCES teacher(teacher_id),
    FOREIGN KEY (subject_id) REFERENCES subject(subject_id)
); 

CREATE TABLE allotted_batch (
    teacher_id INT,
    batch_id INT,
    PRIMARY KEY (teacher_id,class_id),
    FOREIGN KEY (teacher_id) REFERENCES teacher(teacher_id),
    FOREIGN KEY (batch_id) REFERENCES batch(batch_id)
); 

-- Attendance Table
CREATE TABLE attendance_resource (
    attendance_res_id INT PRIMARY KEY AUTO_INCREMENT,
    batch_id INT,
    subject_id INT,
    attendance_date DATE NOT NULL,
    hour TINYINT,
    marked_at DATETIME DEFAULT NOW() ON UPDATE NOW(),
    FOREIGN KEY (batch_id) REFERENCES batch(batch_id),
    FOREIGN KEY (subject_id) REFERENCES subject(subject_id),
    UNIQUE KEY uq_session (batch_id, subject_id, attendance_date, hour)
);

-- Attendance Details Table
CREATE TABLE attendance_info (
    attendance_id INT PRIMARY KEY AUTO_INCREMENT,
    attendance_res_id INT,
    student_id INT,
    status TINYINT(1) NOT NULL,
    FOREIGN KEY (attendance_res_id) REFERENCES attendance_resource(attendance_res_id),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    UNIQUE KEY uq_attendance (attendance_res_id, student_id)
);

-- Result Table
CREATE TABLE result (
    result_id INT PRIMARY KEY AUTO_INCREMENT,
    subject_id INT,
    student_id INT,
    marks_obtained FLOAT,
    total_marks FLOAT,
    exam_name VARCHAR(100),
    exam_date DATE,
    FOREIGN KEY (subject_id) REFERENCES subject(subject_id),
    FOREIGN KEY (student_id) REFERENCES student(student_id)
);


Write insert queries for adding datas into these tables. Insert atleast 5 courses into  branch table. Insert many subjects related to the above inserted courses into the subject table, Insert subjects as much as possible. Isert 8 semester for each branch into semester  table.Insert atleast 5 batches to batch table. Insert 2 or 3 sections for 

Enter section, semester, branch , batch, subject , date 

I wanted to add many dummy datas into student table. So write a code in GO for inserting many datas into the student table. "github.com/brianvoe/gofakeit/v6", use this package to generate random data. No need to randomly generate the email (since email should be unique ) instead use "example"+i+"@gmail.com" ( i is the index in the for loop). Use "bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost) " function of "golang.org/x/crypto/bcrypt" package to hash the password. student_password table is for storing the email and passwords ( actual password not the hashed password ) of dummy students.

SELECT sub.subject_id,sub.name AS subject_name,sub.code AS subject_code,COALESCE(SUM(CASE WHEN ai.status = 1 THEN 1 ELSE 0 END), 0) AS present_days,COUNT(ai.attendance_id) AS total_days,sem.sem_num FROM student s INNER JOIN class c ON s.class_id = c.class_id INNER JOIN semester sem ON c.semester_id = sem.semester_id INNER JOIN subject_cluster sc ON sem.subject_cluster_id = sc.subject_cluster_id INNER JOIN subject_cluster_map scm ON sc.subject_cluster_id = scm.subject_cluster_id INNER JOIN subject sub ON scm.subject_id = sub.subject_id LEFT JOIN attendance_resource ar ON ar.class_id = c.class_id AND ar.subject_id = sub.subject_id LEFT JOIN attendance_info ai ON ai.attendance_res_id = ar.attendance_res_id AND ai.student_id = s.student_id WHERE s.student_id = ? GROUP BY sub.subject_id, sub.name, sub.code, sem.sem_num ORDER BY sem.sem_num DESC, sub.name ASC


INSERT INTO student_class (student_id, class_id, sem_num)
SELECT 
    s.student_id,
    c_prev.class_id,
    sem_prev.sem_num
FROM student s
JOIN class c_curr ON s.class_id = c_curr.class_id
JOIN semester sem_curr ON c_curr.semester_id = sem_curr.semester_id
JOIN semester sem_prev 
    ON sem_prev.branch_id = s.branch_id
    AND sem_prev.sem_num <= sem_curr.sem_num   
JOIN class c_prev 
    ON c_prev.semester_id = sem_prev.semester_id
    AND c_prev.section = c_curr.section       
LEFT JOIN student_class sc
    ON sc.student_id = s.student_id AND sc.class_id = c_prev.class_id
WHERE sc.student_id IS NULL;                  


SELECT 
			sub.subject_id,
			sub.name AS subject_name,
			sub.code AS subject_code,
			stc.sem_num,
			DATE_FORMAT(ar.attendance_date, '%Y-%m-%d') AS attendance_date,
			ar.hour,
			ai.status
		FROM student_class stc
		INNER JOIN class c ON stc.class_id = c.class_id
		INNER JOIN semester sem ON c.semester_id = sem.semester_id
		INNER JOIN subject_cluster sc ON sem.subject_cluster_id = sc.subject_cluster_id
		INNER JOIN subject_cluster_map scm ON sc.subject_cluster_id = scm.subject_cluster_id
		INNER JOIN subject sub ON scm.subject_id = sub.subject_id
		LEFT JOIN attendance_resource ar ON ar.class_id = c.class_id 
			AND ar.subject_id = sub.subject_id
		LEFT JOIN attendance_info ai ON ai.attendance_res_id = ar.attendance_res_id 
			AND ai.student_id = stc.student_id
		WHERE stc.student_id = 1168
		ORDER BY stc.sem_num DESC, sub.name ASC, ar.attendance_date DESC, ar.hour 



Plan:

1. The teacher Selects or enter the  required datas.Frontend sends these datas such as branch_id,batch_id,Semester_num , Section , date and hour to the backend, ( These datas are given in the frontend . Frontend provide the facility to selest these datas for the teacher ) . 
2. Backend finds the semester_id using Semester_num and branch .
3. Then it finds subject_cluster_id using semester_id, and finds the class_id using semester_id and section, ( subject_cluster_id can be used to find the set of subjects given to a particular class , class_id can be used to find the students studying in that class).

4. Then backend sends back branch_id,batch_id,Semester_num , Section , date and hour and along with that backend sends the set of subjects and the class_id.

5. Frontend receives these data and asks the teacher to choose one subject from the list.Teacher Selects one subject.
6. Frontend then sends the subject_id and also sends branch_id,batch_id,Semester_num , Section , date, hour and class_id.
7. Frontend receives this data then it uses these datas to check whether the attendance for this class for that particular session , for that subject has been marked 
7.1 If yes then it sends all the attendance details along with the list of students in the class. It also sends the attendance_res_id in the attendance_resource table for that session.
7.2 If not the backend sends the list of students along with branch_id,batch_id,Semester_num , Section , date, hour and class_id.It also sends the attendance_res_id as null value or empty string ( since attendance is not marked for that session , for that subject).

8. Then frontend receives these data .
8.1 If attendance_res_id is Present , it provides the facility to update the attendance
8.2 else if attendance_res_id is not Present , then it provides facility to mark the attendance for the first time .
9. After this the frontend sends all these datas to the backend.

10. Backend receives the data from the frontend and checks for attendance_res_id .
10.1 If attendance_res_id is Present , then it updates the existing attendance according to the recived data 
10.2 else if attendance_res_id is not Present , then it adds the details to the database as new attendance.

11. Then backend sends success message to the frontend.

So this is my plan.So i am not telling this plan to you to write the code , instead i wanted you to thoroughly review this plan and tell me, is  there any issues in this plan. Suggest your opinions on this plan and tell me if there is  any improvements  needed . Then create a precise and correct prompt, to give it to an AI , so that it generates the proper code, for implementing this feature  in my project . Create seperate prompts for generating the backend code and frontend code .
